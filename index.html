<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>AIESEC</title>
  <style>
    body {
      margin: 0px;
      padding: 0px;
      width: 100vw;
      height: 100vh;
    }
    canvas {
      display: block;
    }
  </style>
  <script src="three.min.js"></script>
  <script src="OrbitControls.js"></script>
  <!-- Custom Shader Code -->
  <script id="vertexShader" type="x-shader/x-vertex">
  uniform float mixAmount;
  varying vec2 vUv;
  void main()
  {
    vUv = uv;
    vec3 goalPosition = 10.0 * vec3( 0, uv.y, -uv.x ) + vec3(0.0, -5.0, 5.0);
    vec3 newPosition = mix( position, goalPosition, mixAmount );
    gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
  }
  </script>

  <!-- fragment shader a.k.a. pixel shader -->
  <script id="fragmentShader" type="x-shader/x-vertex">
  uniform sampler2D baseTexture;
  varying vec2 vUv;
  void main()
  {
      gl_FragColor = texture2D( baseTexture, vUv );
  }
  </script>
</head>
<body>
<script>
    var scene = new THREE.Scene()
    var aspectRatio = window.innerWidth / window.innerHeight
    var camera = new THREE.PerspectiveCamera(45, aspectRatio, 0.1, 10000)
    var earthWidth = 1024
    var earthHeight = 512
    camera.position.z = 40
    var renderer = new THREE.WebGLRenderer()
    renderer.setSize(window.innerWidth, window.innerHeight)
    renderer.setClearColor(0)
    window.addEventListener('resize', function() {
      var WIDTH = window.innerWidth,
          HEIGHT = window.innerHeight;
      renderer.setSize(WIDTH, HEIGHT);
      camera.aspect = WIDTH / HEIGHT;
      camera.updateProjectionMatrix();
    });
    var controls = new THREE.OrbitControls(camera, renderer.domElement)
    controls.enableDamping = true
    controls.dampingFactor = 0.25
    controls.enablePan = false
    controls.enableRotate = true

    var clock = new THREE.Clock()
    var time = 0
    var earthOrbitRadius = 100,
        earthOrbitAngle = 0
        earthOrbitSpeed = 0.5
    document.body.appendChild(renderer.domElement)

    var group = new THREE.Object3D()


    scene.add(new THREE.AmbientLight(0x404040))

    var ambientLight = new THREE.AmbientLight(0xFFFF99)
    scene.add(ambientLight)

    var light = new THREE.PointLight(0xFFFFFF, 0.5, 1)
    light.position.set(0, 30, 40)
    scene.add(light)

    var earthRadius = 10
    var geometry = new THREE.SphereGeometry(earthRadius, 32, 32)
    var bumpTexture = THREE.ImageUtils.loadTexture('images/earth-mercator-bump.png')
    var specularMap = THREE.ImageUtils.loadTexture('images/earth-mercator-specular.png')
    var texture = THREE.ImageUtils.loadTexture("images/earth-mercator.png")

    var earthMaterial = new THREE.MeshPhongMaterial({
        color: 0x9E9E9E,
        specular: 0x333333,
        map: texture,
        bumpMap: bumpTexture,
        bumpScale: 1,
        shininess: 5,
        specularMap: specularMap,
        metal: false,
        specular: 0xE0E0E0,
    })

    var customUniforms = {
      baseTexture: { type: "t", value: texture },
      mixAmount:   { type: "f", value: 0.0 }
    }

    // var customMaterial = new THREE.ShaderMaterial({
    //   uniforms: customUniforms,
    //   vertexShader:   document.getElementById( 'vertexShader'   ).textContent,
    //   fragmentShader: document.getElementById( 'fragmentShader' ).textContent,
    //   side: THREE.DoubleSide
    // })
    var earth = new THREE.Mesh(geometry, earthMaterial)


    var cloud = createEarthCloud()

    var starFieldGeometry  = new THREE.SphereGeometry(500, 32, 32)
    // create the material, using a texture of startfield
    var starFieldMaterial = new THREE.MeshBasicMaterial({
      map: THREE.ImageUtils.loadTexture('images/galaxy_starfield.png'),
      side: THREE.BackSide
    })
    // create the mesh based on geometry and material
    var starField  = new THREE.Mesh(starFieldGeometry, starFieldMaterial)
    scene.add(starField)
    group.add(earth)
    group.add(cloud)
    scene.add(group)
    group.rotation.y = 1.5 * Math.PI

    var loader = new THREE.JSONLoader()
    function createPins(geometry) {
      var pmesh = new THREE.Mesh(geometry, new THREE.MeshPhongMaterial({
        specular: 0x333333,
        color: 0xEC407A,
        shininess: 3
      }))
      var x = 579 / earthWidth
      var y = 171 / earthHeight
      var longitude = ( x / earthRadius ) / (Math.PI * 180)
      var latitude = 2 * Math.atan(Math.exp(y / earthRadius)) / (Math.PI * 180)
      pmesh.position.x = earthRadius * Math.cos(latitude) * Math.cos(longitude)
      pmesh.position.z = earthRadius * Math.cos(latitude) * Math.sin(longitude)
      pmesh.position.y = earthRadius * Math.sin(latitude)
      pmesh.scale.set(0.05, 0.05, 0.05)
      console.log(longitude)
      console.log(latitude)
      console.log(pmesh.position)
      group.add(pmesh)
    }
    loader.load('models/pin.json', createPins)
    var lineMaterial = new THREE.LineBasicMaterial({
        color: 0x0000ff
    });
    var lineGeom = new THREE.Geometry();
    lineGeom.vertices.push(new THREE.Vector3(0, 0, 0));
    lineGeom.vertices.push(new THREE.Vector3(0, 0, 2 * earthRadius));
    var line = new THREE.Line(lineGeom, lineMaterial);
    line.rotation.y =  -5.39 * Math.PI / 180
    line.rotation.x = -35.64 * Math.PI / 180
    scene.add(line)
    var wrapAnimationOn = true
    var mixScale = 2
    var cloudOpacityAnimationOn = false
    // starField.position.z = -10;
    function render() {
        requestAnimationFrame(render)

        var delta = clock.getDelta()
        // group.rotation.y += 0.1 * delta

        // if (wrapAnimationOn) {
        //   var time = clock.getElapsedTime() * 0.5
        //   customUniforms.mixAmount.value = 0.5 * mixScale
        //   mixScale -= 0.01
        //   if (mixScale <= 0) {
        //     wrapAnimationOn = false
        //     cloud.material.opacity = 0
        //     cloudOpacityAnimationOn = true
        //     scene.add(cloud)
        //     customUniforms.mixAmount.value = 0;
        //     controls.enableRotate = true
        //   }
        // } else {

        // }

        // if (cloudOpacityAnimationOn) {
        //   cloud.material.opacity += 0.005
        //   if (cloud.material.opacity >= 0.8) {
        //     cloud.material.opacity = 0.8
        //     cloudOpacityAnimationOn = false
        //   }
        // }
        cloud.rotation.y += 0.1 * delta
        cloud.rotation.z += 0.05 * delta
        controls.update()
        renderer.render(scene, camera)
    }

    render()

    function createEarthCloud() {
      var canvasResult  = document.createElement('canvas')
        canvasResult.width  = 1024
        canvasResult.height = 512
        var contextResult = canvasResult.getContext('2d')

        // load earthcloudmap
        var imageMap  = new Image();
        imageMap.addEventListener("load", function() {
          
          // create dataMap ImageData for earthcloudmap
          var canvasMap = document.createElement('canvas')
          canvasMap.width = imageMap.width
          canvasMap.height= imageMap.height
          var contextMap  = canvasMap.getContext('2d')
          contextMap.drawImage(imageMap, 0, 0)
          var dataMap = contextMap.getImageData(0, 0, canvasMap.width, canvasMap.height)

          // load earthcloudmaptrans
          var imageTrans  = new Image();
          imageTrans.addEventListener("load", function(){
            // create dataTrans ImageData for earthcloudmaptrans
            var canvasTrans   = document.createElement('canvas')
            canvasTrans.width = imageTrans.width
            canvasTrans.height  = imageTrans.height
            var contextTrans  = canvasTrans.getContext('2d')
            contextTrans.drawImage(imageTrans, 0, 0)
            var dataTrans   = contextTrans.getImageData(0, 0, canvasTrans.width, canvasTrans.height)
            // merge dataMap + dataTrans into dataResult
            var dataResult    = contextMap.createImageData(canvasMap.width, canvasMap.height)
            for(var y = 0, offset = 0; y < imageMap.height; y++){
              for(var x = 0; x < imageMap.width; x++, offset += 4){
                dataResult.data[offset+0] = dataMap.data[offset+0]
                dataResult.data[offset+1] = dataMap.data[offset+1]
                dataResult.data[offset+2] = dataMap.data[offset+2]
                dataResult.data[offset+3] = 255 - dataTrans.data[offset+0]
              }
            }
            // update texture with result
            contextResult.putImageData(dataResult,0,0)
            material.map.needsUpdate = true;
          })
          imageTrans.src  = 'images/earthcloudmaptrans.jpg';
        }, false);
        imageMap.src  = 'images/earthcloudmap.jpg';

        var geometry  = new THREE.SphereGeometry(earthRadius + 0.2, 32, 32)
        var material  = new THREE.MeshPhongMaterial({
          map   : new THREE.Texture(canvasResult),
          side    : THREE.DoubleSide,
          transparent : true,
          opacity   : 0.8,
        })
        var mesh  = new THREE.Mesh(geometry, material)
        return mesh
    }
</script>
</body>
</html>